{"id":"spanner/v1/doc/doc_transaction","type":"class","overview":"<p>\n  This class allows you interact with Cloud Spanner.\n</p>\n\n\n\n<p>\n  First, install <code>@google-cloud/spanner</code> with npm:\n</p>\n\n<div hljs language=\"bash\">$ npm install --save @google-cloud/spanner</div>\n\n<p>\n  If you are running your app on Google Compute Engine, you won't need to worry about supplying connection configuration options to <code>@google-cloud/spanner</code>â€” we figure that out for you.\n</p>\n\n<p>\n  However, if you're running your app elsewhere, you will need to provide project details to authenticate API requests.\n</p>\n\n<h4>Google Cloud Platform</h4>\n<div hljs language=\"javascript\">\nvar spanner = require('@google-cloud/spanner')();\n</div>\n\n<h4>Elsewhere</h4>\n<div hljs language=\"javascript\">\nvar spanner = require('@google-cloud/spanner')({\n  projectId: 'grape-spaceship-123',\n  keyFilename: '/path/to/keyfile.json'\n});\n</div>\n\n<p>\n  The full set of options which can be passed to <code>@google-cloud/spanner</code> are outlined in our <a href=\"#/docs/spanner/v0.7.0/guides/authentication\">Authentication guide</a>.\n</p>\n","source":"packages\\spanner\\src\\v1\\doc\\doc_transaction.js","parent":"spanner","children":[],"methods":[{"id":"TransactionOptions","name":"TransactionOptions","type":"instance","description":"<h1>Transactions</h1> <p>Each session can have at most one active transaction at a time. After the active transaction is completed, the session can immediately be re-used for the next transaction. It is not necessary to create a new session for each transaction.</p><h1>Transaction Modes</h1> <p>Cloud Spanner supports two transaction modes:</p><ol> <li><p>Locking read-write. This type of transaction is the only way to write data into Cloud Spanner. These transactions rely on pessimistic locking and, if necessary, two-phase commit. Locking read-write transactions may abort, requiring the application to retry.</p></li> <li><p>Snapshot read-only. This transaction type provides guaranteed consistency across several reads, but does not allow writes. Snapshot read-only transactions can be configured to read at timestamps in the past. Snapshot read-only transactions do not need to be committed.</p></li> </ol> <p>For transactions that only read, snapshot read-only transactions provide simpler semantics and are almost always faster. In particular, read-only transactions do not take locks, so they do not conflict with read-write transactions. As a consequence of not taking locks, they also do not abort, so retry loops are not needed.</p><p>Transactions may only read/write data in a single database. They may, however, read/write data in different tables within that database.</p><h2>Locking Read-Write Transactions</h2> <p>Locking transactions may be used to atomically read-modify-write data anywhere in a database. This type of transaction is externally consistent.</p><p>Clients should attempt to minimize the amount of time a transaction is active. Faster transactions commit with higher probability and cause less contention. Cloud Spanner attempts to keep read locks active as long as the transaction continues to do reads, and the transaction has not been terminated by {@link Commit} or {@link Rollback}. Long periods of inactivity at the client may cause Cloud Spanner to release a transaction&#39;s locks and abort it.</p><p>Reads performed within a transaction acquire locks on the data being read. Writes can only be done at commit time, after all reads have been completed. Conceptually, a read-write transaction consists of zero or more reads or SQL queries followed by {@link Commit}. At any time before {@link Commit}, the client can send a {@link Rollback} request to abort the transaction.</p><h3>Semantics</h3> <p>Cloud Spanner can commit the transaction if all read locks it acquired are still valid at commit time, and it is able to acquire write locks for all writes. Cloud Spanner can abort the transaction for any reason. If a commit attempt returns <code>ABORTED</code>, Cloud Spanner guarantees that the transaction has not modified any user data in Cloud Spanner.</p><p>Unless the transaction commits, Cloud Spanner makes no guarantees about how long the transaction&#39;s locks were held for. It is an error to use Cloud Spanner locks for any sort of mutual exclusion other than between Cloud Spanner transactions themselves.</p><h3>Retrying Aborted Transactions</h3> <p>When a transaction aborts, the application can choose to retry the whole transaction again. To maximize the chances of successfully committing the retry, the client should execute the retry in the same session as the original attempt. The original session&#39;s lock priority increases with each consecutive abort, meaning that each attempt has a slightly better chance of success than the previous.</p><p>Under some circumstances (e.g., many transactions attempting to modify the same row(s)), a transaction can abort many times in a short period before successfully committing. Thus, it is not a good idea to cap the number of retries a transaction can attempt; instead, it is better to limit the total amount of wall time spent retrying.</p><h3>Idle Transactions</h3> <p>A transaction is considered idle if it has no outstanding reads or SQL queries and has not started a read or SQL query within the last 10 seconds. Idle transactions can be aborted by Cloud Spanner so that they don&#39;t hold on to locks indefinitely. In that case, the commit will fail with error <code>ABORTED</code>.</p><p>If this behavior is undesirable, periodically executing a simple SQL query in the transaction (e.g., <code>SELECT 1</code>) prevents the transaction from becoming idle.</p><h2>Snapshot Read-Only Transactions</h2> <p>Snapshot read-only transactions provides a simpler method than locking read-write transactions for doing several consistent reads. However, this type of transaction does not support writes.</p><p>Snapshot transactions do not take locks. Instead, they work by choosing a Cloud Spanner timestamp, then executing all reads at that timestamp. Since they do not acquire locks, they do not block concurrent read-write transactions.</p><p>Unlike locking read-write transactions, snapshot read-only transactions never abort. They can fail if the chosen read timestamp is garbage collected; however, the default garbage collection policy is generous enough that most applications do not need to worry about this in practice.</p><p>Snapshot read-only transactions do not need to call {@link Commit} or {@link Rollback} (and in fact are not permitted to do so).</p><p>To execute a snapshot transaction, the client specifies a timestamp bound, which tells Cloud Spanner how to choose a read timestamp.</p><p>The types of timestamp bound are:</p><ul> <li>Strong (the default).</li> <li>Bounded staleness.</li> <li>Exact staleness.</li> </ul> <p>If the Cloud Spanner database to be read is geographically distributed, stale read-only transactions can execute more quickly than strong or read-write transaction, because they are able to execute far from the leader replica.</p><p>Each type of timestamp bound is discussed in detail below.</p><h3>Strong</h3> <p>Strong reads are guaranteed to see the effects of all transactions that have committed before the start of the read. Furthermore, all rows yielded by a single read are consistent with each other -- if any part of the read observes a transaction, all parts of the read see the transaction.</p><p>Strong reads are not repeatable: two consecutive strong read-only transactions might return inconsistent results if there are concurrent writes. If consistency across reads is required, the reads should be executed within a transaction or at an exact read timestamp.</p><p>See {@link TransactionOptions.ReadOnly.strong}.</p><h3>Exact Staleness</h3> <p>These timestamp bounds execute reads at a user-specified timestamp. Reads at a timestamp are guaranteed to see a consistent prefix of the global transaction history: they observe modifications done by all transactions with a commit timestamp &lt;= the read timestamp, and observe none of the modifications done by transactions with a larger commit timestamp. They will block until all conflicting transactions that may be assigned commit timestamps &lt;= the read timestamp have finished.</p><p>The timestamp can either be expressed as an absolute Cloud Spanner commit timestamp or a staleness relative to the current time.</p><p>These modes do not require a &quot;negotiation phase&quot; to pick a timestamp. As a result, they execute slightly faster than the equivalent boundedly stale concurrency modes. On the other hand, boundedly stale reads usually return fresher results.</p><p>See {@link TransactionOptions.ReadOnly.read_timestamp} and {@link TransactionOptions.ReadOnly.exact_staleness}.</p><h3>Bounded Staleness</h3> <p>Bounded staleness modes allow Cloud Spanner to pick the read timestamp, subject to a user-provided staleness bound. Cloud Spanner chooses the newest timestamp within the staleness bound that allows execution of the reads at the closest available replica without blocking.</p><p>All rows yielded are consistent with each other -- if any part of the read observes a transaction, all parts of the read see the transaction. Boundedly stale reads are not repeatable: two stale reads, even if they use the same staleness bound, can execute at different timestamps and thus return inconsistent results.</p><p>Boundedly stale reads execute in two phases: the first phase negotiates a timestamp among all replicas needed to serve the read. In the second phase, reads are executed at the negotiated timestamp.</p><p>As a result of the two phase execution, bounded staleness reads are usually a little slower than comparable exact staleness reads. However, they are typically able to return fresher results, and are more likely to execute at the closest replica.</p><p>Because the timestamp negotiation requires up-front knowledge of which rows will be read, it can only be used with single-use read-only transactions.</p><p>See {@link TransactionOptions.ReadOnly.max_staleness} and {@link TransactionOptions.ReadOnly.min_read_timestamp}.</p><h3>Old Read Timestamps and Garbage Collection</h3> <p>Cloud Spanner continuously garbage collects deleted and overwritten data in the background to reclaim storage space. This process is known as &quot;version GC&quot;. By default, version GC reclaims versions after they are one hour old. Because of this, Cloud Spanner cannot perform reads at read timestamps more than one hour in the past. This restriction also applies to in-progress reads and/or SQL queries whose timestamp become too old while executing. Reads and SQL queries with too-old read timestamps fail with the error <code>FAILED_PRECONDITION</code>.</p>","source":"packages\\spanner\\src\\v1\\doc\\doc_transaction.js#L261","resources":[],"examples":[],"params":[{"name":"readWrite","description":"<p> Transaction may write.</p><p> Authorization to begin a read-write transaction requires  <code>spanner.databases.beginOrRollbackReadWriteTransaction</code> permission  on the <code>session</code> resource.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'ReadWrite'\n        })\">ReadWrite</a></p>","types":["Object"],"optional":false,"nullable":false},{"name":"readOnly","description":"<p> Transaction will not write.</p><p> Authorization to begin a read-only transaction requires  <code>spanner.databases.beginReadOnlyTransaction</code> permission  on the <code>session</code> resource.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'ReadOnly'\n        })\">ReadOnly</a></p>","types":["Object"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"ReadWrite","name":"ReadWrite","type":"instance","description":"<p>Options for read-write transactions.</p>","source":"packages\\spanner\\src\\v1\\doc\\doc_transaction.js#L269","resources":[],"examples":[],"params":[],"exceptions":[],"returns":[]},{"id":"ReadOnly","name":"ReadOnly","type":"instance","description":"<p>Options for read-only transactions.</p>","source":"packages\\spanner\\src\\v1\\doc\\doc_transaction.js#L343","resources":[],"examples":[],"params":[{"name":"strong","description":"<p> Read at a timestamp where all previously committed transactions  are visible.</p>","types":["boolean"],"optional":false,"nullable":false},{"name":"minReadTimestamp","description":"<p> Executes all reads at a timestamp &gt;= <code>min_read_timestamp</code>.</p><p> This is useful for requesting fresher data than some previous  read, or data that is fresh enough to observe the effects of some  previously committed transaction whose timestamp is known.</p><p> Note that this option can only be used in single-use transactions.</p><p> This object should have the same structure as google.protobuf.Timestamp</p>","types":["Object"],"optional":false,"nullable":false},{"name":"maxStaleness","description":"<p> Read data at a timestamp &gt;= <code>NOW - max_staleness</code>  seconds. Guarantees that all writes that have committed more  than the specified number of seconds ago are visible. Because  Cloud Spanner chooses the exact timestamp, this mode works even if  the client&#39;s local clock is substantially skewed from Cloud Spanner  commit timestamps.</p><p> Useful for reading the freshest data available at a nearby  replica, while bounding the possible staleness if the local  replica has fallen behind.</p><p> Note that this option can only be used in single-use  transactions.</p><p> This object should have the same structure as google.protobuf.Duration</p>","types":["Object"],"optional":false,"nullable":false},{"name":"readTimestamp","description":"<p> Executes all reads at the given timestamp. Unlike other modes,  reads at a specific timestamp are repeatable; the same read at  the same timestamp always returns the same data. If the  timestamp is in the future, the read will block until the  specified timestamp, modulo the read&#39;s deadline.</p><p> Useful for large scale consistent reads such as mapreduces, or  for coordinating many reads against a consistent snapshot of the  data.</p><p> This object should have the same structure as google.protobuf.Timestamp</p>","types":["Object"],"optional":false,"nullable":false},{"name":"exactStaleness","description":"<p> Executes all reads at a timestamp that is <code>exact_staleness</code>  old. The timestamp is chosen soon after the read is started.</p><p> Guarantees that all writes that have committed more than the  specified number of seconds ago are visible. Because Cloud Spanner  chooses the exact timestamp, this mode works even if the client&#39;s  local clock is substantially skewed from Cloud Spanner commit  timestamps.</p><p> Useful for reading at nearby replicas without the distributed  timestamp negotiation overhead of <code>max_staleness</code>.</p><p> This object should have the same structure as google.protobuf.Duration</p>","types":["Object"],"optional":false,"nullable":false},{"name":"returnReadTimestamp","description":"<p> If true, the Cloud Spanner-selected read timestamp is included in  the {@link Transaction} message that describes the transaction.</p>","types":["boolean"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"Transaction","name":"Transaction","type":"instance","description":"<p>A transaction.</p>","source":"packages\\spanner\\src\\v1\\doc\\doc_transaction.js#L371","resources":[],"examples":[],"params":[{"name":"id","description":"<p> <code>id</code> may be used to identify the transaction in subsequent  {@link Read},  {@link ExecuteSql},  {@link Commit}, or  {@link Rollback} calls.</p><p> Single-use read-only transactions do not have IDs, because  single-use transactions do not support multiple requests.</p>","types":["string"],"optional":false,"nullable":false},{"name":"readTimestamp","description":"<p> For snapshot read-only transactions, the read timestamp chosen  for the transaction. Not returned by default: see  {@link TransactionOptions.ReadOnly.return_read_timestamp}.</p><p> This object should have the same structure as google.protobuf.Timestamp</p>","types":["Object"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"TransactionSelector","name":"TransactionSelector","type":"instance","description":"<p>This message is used to select the transaction in which a {@link Read} or {@link ExecuteSql} call runs.</p><p>See {@link TransactionOptions} for more information about transactions.</p>","source":"packages\\spanner\\src\\v1\\doc\\doc_transaction.js#L402","resources":[],"examples":[],"params":[{"name":"singleUse","description":"<p> Execute the read or SQL query in a temporary transaction.  This is the most efficient way to execute a transaction that  consists of a single SQL query.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TransactionOptions'\n        })\">TransactionOptions</a></p>","types":["Object"],"optional":false,"nullable":false},{"name":"id","description":"<p> Execute the read or SQL query in a previously-started transaction.</p>","types":["string"],"optional":false,"nullable":false},{"name":"begin","description":"<p> Begin a new transaction and execute this read or SQL query in  it. The transaction ID of the new transaction is returned in  {@link ResultSetMetadata.transaction}, which is a {@link Transaction}.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TransactionOptions'\n        })\">TransactionOptions</a></p>","types":["Object"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]}],"path":"doc_transaction.json"}