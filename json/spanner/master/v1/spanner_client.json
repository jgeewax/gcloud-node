{"id":"spanner/v1/spanner_client","type":"class","overview":"<p>\n  This class allows you interact with Cloud Spanner.\n</p>\n\n\n\n<p>\n  First, install <code>@google-cloud/spanner</code> with npm:\n</p>\n\n<div hljs language=\"bash\">$ npm install --save @google-cloud/spanner</div>\n\n<p>\n  If you are running your app on Google Compute Engine, you won't need to worry about supplying connection configuration options to <code>@google-cloud/spanner</code>â€” we figure that out for you.\n</p>\n\n<p>\n  However, if you're running your app elsewhere, you will need to provide project details to authenticate API requests.\n</p>\n\n<h4>Google Cloud Platform</h4>\n<div hljs language=\"javascript\">\nvar spanner = require('@google-cloud/spanner')();\n</div>\n\n<h4>Elsewhere</h4>\n<div hljs language=\"javascript\">\nvar spanner = require('@google-cloud/spanner')({\n  projectId: 'grape-spaceship-123',\n  keyFilename: '/path/to/keyfile.json'\n});\n</div>\n\n<p>\n  The full set of options which can be passed to <code>@google-cloud/spanner</code> are outlined in our <a href=\"#/docs/spanner/v0.5.0/guides/authentication\">Authentication guide</a>.\n</p>\n","source":"packages\\spanner\\src\\v1\\spanner_client.js","parent":"spanner","children":[],"methods":[{"id":"SpannerClient","name":"SpannerClient","type":"constructor","description":"<p>Cloud Spanner API</p><p>The Cloud Spanner API can be used to manage sessions and execute transactions on data stored in Cloud Spanner databases.</p><p>This will be created through a builder function which can be obtained by the module. See the following example of how to initialize the module and how to access to the builder.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L72","resources":[],"examples":[{"code":"var spannerV1 = require('@google-cloud/spanner').v1({\n  // optional auth parameters.\n});\nvar client = spannerV1.spannerClient();"}],"params":[],"exceptions":[],"returns":[]},{"id":"databasePath","name":"databasePath","type":"instance","description":"<p>Returns a fully-qualified database resource name string.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L143","resources":[],"examples":[],"params":[{"name":"project","description":"","types":["String"],"optional":false,"nullable":false},{"name":"instance","description":"","types":["String"],"optional":false,"nullable":false},{"name":"database","description":"","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"matchProjectFromDatabaseName","name":"matchProjectFromDatabaseName","type":"instance","description":"<p>Parses the databaseName from a database resource.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L157","resources":[],"examples":[],"params":[{"name":"databaseName","description":"<p> A fully-qualified path representing a database resources.</p>","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"matchInstanceFromDatabaseName","name":"matchInstanceFromDatabaseName","type":"instance","description":"<p>Parses the databaseName from a database resource.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L167","resources":[],"examples":[],"params":[{"name":"databaseName","description":"<p> A fully-qualified path representing a database resources.</p>","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"matchDatabaseFromDatabaseName","name":"matchDatabaseFromDatabaseName","type":"instance","description":"<p>Parses the databaseName from a database resource.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L177","resources":[],"examples":[],"params":[{"name":"databaseName","description":"<p> A fully-qualified path representing a database resources.</p>","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"sessionPath","name":"sessionPath","type":"instance","description":"<p>Returns a fully-qualified session resource name string.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L189","resources":[],"examples":[],"params":[{"name":"project","description":"","types":["String"],"optional":false,"nullable":false},{"name":"instance","description":"","types":["String"],"optional":false,"nullable":false},{"name":"database","description":"","types":["String"],"optional":false,"nullable":false},{"name":"session","description":"","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"matchProjectFromSessionName","name":"matchProjectFromSessionName","type":"instance","description":"<p>Parses the sessionName from a session resource.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L204","resources":[],"examples":[],"params":[{"name":"sessionName","description":"<p> A fully-qualified path representing a session resources.</p>","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"matchInstanceFromSessionName","name":"matchInstanceFromSessionName","type":"instance","description":"<p>Parses the sessionName from a session resource.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L214","resources":[],"examples":[],"params":[{"name":"sessionName","description":"<p> A fully-qualified path representing a session resources.</p>","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"matchDatabaseFromSessionName","name":"matchDatabaseFromSessionName","type":"instance","description":"<p>Parses the sessionName from a session resource.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L224","resources":[],"examples":[],"params":[{"name":"sessionName","description":"<p> A fully-qualified path representing a session resources.</p>","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"matchSessionFromSessionName","name":"matchSessionFromSessionName","type":"instance","description":"<p>Parses the sessionName from a session resource.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L234","resources":[],"examples":[],"params":[{"name":"sessionName","description":"<p> A fully-qualified path representing a session resources.</p>","types":["String"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"getProjectId","name":"getProjectId","type":"instance","description":"<p>Get the project ID used by this class.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L243","resources":[],"examples":[],"params":[],"exceptions":[],"returns":[]},{"id":"createSession","name":"createSession","type":"instance","description":"<p>Creates a new session. A session can be used to perform transactions that read and/or modify data in a Cloud Spanner database. Sessions are meant to be reused for many consecutive transactions.</p><p>Sessions can only execute one transaction at a time. To execute multiple concurrent read-write/write-only transactions, create multiple sessions. Note that standalone reads and queries use a transaction internally, and count toward the one transaction limit.</p><p>Cloud Spanner limits the number of sessions that can exist at any given time; thus, it is a good idea to delete idle and/or unneeded sessions. Aside from explicit deletes, Cloud Spanner can delete sessions for which no operations are sent for more than an hour. If a session is deleted, requests to it return <code>NOT_FOUND</code>.</p><p>Idle sessions can be kept alive by sending a trivial SQL query periodically, e.g., <code>&quot;SELECT 1&quot;</code>.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L296","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedDatabase = client.databasePath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\");\nclient.createSession({database: formattedDatabase}).then(function(responses) {\n    var response = responses[0];\n    // doThingsWith(response)\n}).catch(function(err) {\n    console.error(err);\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.database","description":"<p> Required. The database in which the new session is created.</p>","types":["string"],"optional":false,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false},{"name":"callback","description":"<p> The function which will be called with the result of the API call.</p><p> The second parameter to the callback is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Session'\n        })\">Session</a>.</p>","types":["function(Error|null, Object|null)"],"optional":true,"nullable":false}],"exceptions":[],"returns":[{"types":["Promise"],"description":"<ul> <li>The promise which resolves to an array. The first element of the array is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Session'\n        })\">Session</a>. The promise has a method named &quot;cancel&quot; which cancels the ongoing API call.</li> </ul> "}]},{"id":"getSession","name":"getSession","type":"instance","description":"<p>Gets a session. Returns <code>NOT_FOUND</code> if the session does not exist. This is mainly useful for determining whether a session is still alive.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L339","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedName = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nclient.getSession({name: formattedName}).then(function(responses) {\n    var response = responses[0];\n    // doThingsWith(response)\n}).catch(function(err) {\n    console.error(err);\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.name","description":"<p> Required. The name of the session to retrieve.</p>","types":["string"],"optional":false,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false},{"name":"callback","description":"<p> The function which will be called with the result of the API call.</p><p> The second parameter to the callback is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Session'\n        })\">Session</a>.</p>","types":["function(Error|null, Object|null)"],"optional":true,"nullable":false}],"exceptions":[],"returns":[{"types":["Promise"],"description":"<ul> <li>The promise which resolves to an array. The first element of the array is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Session'\n        })\">Session</a>. The promise has a method named &quot;cancel&quot; which cancels the ongoing API call.</li> </ul> "}]},{"id":"deleteSession","name":"deleteSession","type":"instance","description":"<p>Ends a session, releasing server resources associated with it.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L374","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedName = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nclient.deleteSession({name: formattedName}).catch(function(err) {\n    console.error(err);\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.name","description":"<p> Required. The name of the session to delete.</p>","types":["string"],"optional":false,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false},{"name":"callback","description":"<p> The function which will be called with the result of the API call.</p>","types":["function(Error|null)"],"optional":true,"nullable":false}],"exceptions":[],"returns":[{"types":["Promise"],"description":"<ul> <li>The promise which resolves when API call finishes. The promise has a method named &quot;cancel&quot; which cancels the ongoing API call.</li> </ul> "}]},{"id":"executeSql","name":"executeSql","type":"instance","description":"<p>Executes an SQL query, returning all rows in a single reply. This method cannot be used to return a result set larger than 10 MiB; if the query yields more data than that, the query fails with a <code>FAILED_PRECONDITION</code> error.</p><p>Queries inside read-write transactions might return <code>ABORTED</code>. If this occurs, the application should restart the transaction from the beginning. See {@link Transaction} for more details.</p><p>Larger result sets can be fetched in streaming fashion by calling {@link ExecuteStreamingSql} instead.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L475","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedSession = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nvar sql = '';\nvar request = {\n    session: formattedSession,\n    sql: sql\n};\nclient.executeSql(request).then(function(responses) {\n    var response = responses[0];\n    // doThingsWith(response)\n}).catch(function(err) {\n    console.error(err);\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.session","description":"<p> Required. The session in which the SQL query should be performed.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.sql","description":"<p> Required. The SQL query string.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.transaction","description":"<p> The transaction to use. If none is provided, the default is a  temporary read-only transaction with strong concurrency.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TransactionSelector'\n        })\">TransactionSelector</a></p>","types":["Object"],"optional":true,"nullable":false},{"name":"request.params","description":"<p> The SQL query string can contain parameter placeholders. A parameter  placeholder consists of <code>&#39;@&#39;</code> followed by the parameter  name. Parameter names consist of any combination of letters,  numbers, and underscores.</p><p> Parameters can appear anywhere that a literal value is expected. The same  parameter name can be used more than once, for example:  <code>&quot;WHERE id &gt; @msg_id AND id &lt; @msg_id + 100&quot;</code></p><p> It is an error to execute an SQL query with unbound parameters.</p><p> Parameter values are specified using <code>params</code>, which is a JSON  object whose keys are parameter names, and whose values are the  corresponding parameter values.</p><p> This object should have the same structure as google.protobuf.Struct</p>","types":["Object"],"optional":true,"nullable":false},{"name":"request.paramTypes","description":"<p> It is not always possible for Cloud Spanner to infer the right SQL type  from a JSON value. For example, values of type <code>BYTES</code> and values  of type <code>STRING</code> both appear in {@link params} as JSON strings.</p><p> In these cases, <code>param_types</code> can be used to specify the exact  SQL type for some or all of the SQL query parameters. See the  definition of {@link Type} for more information  about SQL types.</p>","types":["Object.<string, Object>"],"optional":true,"nullable":false},{"name":"request.resumeToken","description":"<p> If this request is resuming a previously interrupted SQL query  execution, <code>resume_token</code> should be copied from the last  {@link PartialResultSet} yielded before the interruption. Doing this  enables the new SQL query execution to resume where the last one left  off. The rest of the request parameters must exactly match the  request that yielded this token.</p>","types":["string"],"optional":true,"nullable":false},{"name":"request.queryMode","description":"<p> Used to control the amount of debugging information returned in  {@link ResultSetStats}.</p><p> The number should be among the values of <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'QueryMode'\n        })\">QueryMode</a></p>","types":["number"],"optional":true,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false},{"name":"callback","description":"<p> The function which will be called with the result of the API call.</p><p> The second parameter to the callback is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'ResultSet'\n        })\">ResultSet</a>.</p>","types":["function(Error|null, Object|null)"],"optional":true,"nullable":false}],"exceptions":[],"returns":[{"types":["Promise"],"description":"<ul> <li>The promise which resolves to an array. The first element of the array is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'ResultSet'\n        })\">ResultSet</a>. The promise has a method named &quot;cancel&quot; which cancels the ongoing API call.</li> </ul> "}]},{"id":"executeStreamingSql","name":"executeStreamingSql","type":"instance","description":"<p>Like {@link ExecuteSql}, except returns the result set as a stream. Unlike {@link ExecuteSql}, there is no limit on the size of the returned result set. However, no individual row in the result set can exceed 100 MiB, and no column value can exceed 10 MiB.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L562","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedSession = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nvar sql = '';\nvar request = {\n    session: formattedSession,\n    sql: sql\n};\nclient.executeStreamingSql(request).on('data', function(response) {\n    // doThingsWith(response)\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.session","description":"<p> Required. The session in which the SQL query should be performed.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.sql","description":"<p> Required. The SQL query string.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.transaction","description":"<p> The transaction to use. If none is provided, the default is a  temporary read-only transaction with strong concurrency.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TransactionSelector'\n        })\">TransactionSelector</a></p>","types":["Object"],"optional":true,"nullable":false},{"name":"request.params","description":"<p> The SQL query string can contain parameter placeholders. A parameter  placeholder consists of <code>&#39;@&#39;</code> followed by the parameter  name. Parameter names consist of any combination of letters,  numbers, and underscores.</p><p> Parameters can appear anywhere that a literal value is expected. The same  parameter name can be used more than once, for example:  <code>&quot;WHERE id &gt; @msg_id AND id &lt; @msg_id + 100&quot;</code></p><p> It is an error to execute an SQL query with unbound parameters.</p><p> Parameter values are specified using <code>params</code>, which is a JSON  object whose keys are parameter names, and whose values are the  corresponding parameter values.</p><p> This object should have the same structure as google.protobuf.Struct</p>","types":["Object"],"optional":true,"nullable":false},{"name":"request.paramTypes","description":"<p> It is not always possible for Cloud Spanner to infer the right SQL type  from a JSON value. For example, values of type <code>BYTES</code> and values  of type <code>STRING</code> both appear in {@link params} as JSON strings.</p><p> In these cases, <code>param_types</code> can be used to specify the exact  SQL type for some or all of the SQL query parameters. See the  definition of {@link Type} for more information  about SQL types.</p>","types":["Object.<string, Object>"],"optional":true,"nullable":false},{"name":"request.resumeToken","description":"<p> If this request is resuming a previously interrupted SQL query  execution, <code>resume_token</code> should be copied from the last  {@link PartialResultSet} yielded before the interruption. Doing this  enables the new SQL query execution to resume where the last one left  off. The rest of the request parameters must exactly match the  request that yielded this token.</p>","types":["string"],"optional":true,"nullable":false},{"name":"request.queryMode","description":"<p> Used to control the amount of debugging information returned in  {@link ResultSetStats}.</p><p> The number should be among the values of <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'QueryMode'\n        })\">QueryMode</a></p>","types":["number"],"optional":true,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false}],"exceptions":[],"returns":[]},{"id":"read","name":"read","type":"instance","description":"<p>Reads rows from the database using key lookups and scans, as a simple key/value style alternative to {@link ExecuteSql}. This method cannot be used to return a result set larger than 10 MiB; if the read matches more data than that, the read fails with a <code>FAILED_PRECONDITION</code> error.</p><p>Reads inside read-write transactions might return <code>ABORTED</code>. If this occurs, the application should restart the transaction from the beginning. See {@link Transaction} for more details.</p><p>Larger result sets can be yielded in streaming fashion by calling {@link StreamingRead} instead.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L657","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedSession = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nvar table = '';\nvar columns = [];\nvar keySet = {};\nvar request = {\n    session: formattedSession,\n    table: table,\n    columns: columns,\n    keySet: keySet\n};\nclient.read(request).then(function(responses) {\n    var response = responses[0];\n    // doThingsWith(response)\n}).catch(function(err) {\n    console.error(err);\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.session","description":"<p> Required. The session in which the read should be performed.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.table","description":"<p> Required. The name of the table in the database to be read.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.columns","description":"<p> The columns of {@link table} to be returned for each row matching  this request.</p>","types":["string[]"],"optional":false,"nullable":false},{"name":"request.keySet","description":"<p> Required. <code>key_set</code> identifies the rows to be yielded. <code>key_set</code> names the  primary keys of the rows in {@link table} to be yielded, unless {@link index}  is present. If {@link index} is present, then {@link key_set} instead names  index keys in {@link index}.</p><p> Rows are yielded in table primary key order (if {@link index} is empty)  or index key order (if {@link index} is non-empty).</p><p> It is not an error for the <code>key_set</code> to name rows that do not  exist in the database. Read yields nothing for nonexistent rows.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'KeySet'\n        })\">KeySet</a></p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.transaction","description":"<p> The transaction to use. If none is provided, the default is a  temporary read-only transaction with strong concurrency.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TransactionSelector'\n        })\">TransactionSelector</a></p>","types":["Object"],"optional":true,"nullable":false},{"name":"request.index","description":"<p> If non-empty, the name of an index on {@link table}. This index is  used instead of the table primary key when interpreting {@link key_set}  and sorting result rows. See {@link key_set} for further information.</p>","types":["string"],"optional":true,"nullable":false},{"name":"request.limit","description":"<p> If greater than zero, only the first <code>limit</code> rows are yielded. If <code>limit</code>  is zero, the default is no limit.</p>","types":["number"],"optional":true,"nullable":false},{"name":"request.resumeToken","description":"<p> If this request is resuming a previously interrupted read,  <code>resume_token</code> should be copied from the last  {@link PartialResultSet} yielded before the interruption. Doing this  enables the new read to resume where the last read left off. The  rest of the request parameters must exactly match the request  that yielded this token.</p>","types":["string"],"optional":true,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false},{"name":"callback","description":"<p> The function which will be called with the result of the API call.</p><p> The second parameter to the callback is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'ResultSet'\n        })\">ResultSet</a>.</p>","types":["function(Error|null, Object|null)"],"optional":true,"nullable":false}],"exceptions":[],"returns":[{"types":["Promise"],"description":"<ul> <li>The promise which resolves to an array. The first element of the array is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'ResultSet'\n        })\">ResultSet</a>. The promise has a method named &quot;cancel&quot; which cancels the ongoing API call.</li> </ul> "}]},{"id":"streamingRead","name":"streamingRead","type":"instance","description":"<p>Like {@link Read}, except returns the result set as a stream. Unlike {@link Read}, there is no limit on the size of the returned result set. However, no individual row in the result set can exceed 100 MiB, and no column value can exceed 10 MiB.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L740","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedSession = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nvar table = '';\nvar columns = [];\nvar keySet = {};\nvar request = {\n    session: formattedSession,\n    table: table,\n    columns: columns,\n    keySet: keySet\n};\nclient.streamingRead(request).on('data', function(response) {\n    // doThingsWith(response)\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.session","description":"<p> Required. The session in which the read should be performed.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.table","description":"<p> Required. The name of the table in the database to be read.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.columns","description":"<p> The columns of {@link table} to be returned for each row matching  this request.</p>","types":["string[]"],"optional":false,"nullable":false},{"name":"request.keySet","description":"<p> Required. <code>key_set</code> identifies the rows to be yielded. <code>key_set</code> names the  primary keys of the rows in {@link table} to be yielded, unless {@link index}  is present. If {@link index} is present, then {@link key_set} instead names  index keys in {@link index}.</p><p> Rows are yielded in table primary key order (if {@link index} is empty)  or index key order (if {@link index} is non-empty).</p><p> It is not an error for the <code>key_set</code> to name rows that do not  exist in the database. Read yields nothing for nonexistent rows.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'KeySet'\n        })\">KeySet</a></p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.transaction","description":"<p> The transaction to use. If none is provided, the default is a  temporary read-only transaction with strong concurrency.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TransactionSelector'\n        })\">TransactionSelector</a></p>","types":["Object"],"optional":true,"nullable":false},{"name":"request.index","description":"<p> If non-empty, the name of an index on {@link table}. This index is  used instead of the table primary key when interpreting {@link key_set}  and sorting result rows. See {@link key_set} for further information.</p>","types":["string"],"optional":true,"nullable":false},{"name":"request.limit","description":"<p> If greater than zero, only the first <code>limit</code> rows are yielded. If <code>limit</code>  is zero, the default is no limit.</p>","types":["number"],"optional":true,"nullable":false},{"name":"request.resumeToken","description":"<p> If this request is resuming a previously interrupted read,  <code>resume_token</code> should be copied from the last  {@link PartialResultSet} yielded before the interruption. Doing this  enables the new read to resume where the last read left off. The  rest of the request parameters must exactly match the request  that yielded this token.</p>","types":["string"],"optional":true,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false}],"exceptions":[],"returns":[]},{"id":"beginTransaction","name":"beginTransaction","type":"instance","description":"<p>Begins a new transaction. This step can often be skipped: {@link Read}, {@link ExecuteSql} and {@link Commit} can begin a new transaction as a side-effect.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L789","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedSession = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nvar options = {};\nvar request = {\n    session: formattedSession,\n    options: options\n};\nclient.beginTransaction(request).then(function(responses) {\n    var response = responses[0];\n    // doThingsWith(response)\n}).catch(function(err) {\n    console.error(err);\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.session","description":"<p> Required. The session in which the transaction runs.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.options","description":"<p> Required. Options for the new transaction.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TransactionOptions'\n        })\">TransactionOptions</a></p>","types":["Object"],"optional":false,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false},{"name":"callback","description":"<p> The function which will be called with the result of the API call.</p><p> The second parameter to the callback is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Transaction'\n        })\">Transaction</a>.</p>","types":["function(Error|null, Object|null)"],"optional":true,"nullable":false}],"exceptions":[],"returns":[{"types":["Promise"],"description":"<ul> <li>The promise which resolves to an array. The first element of the array is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Transaction'\n        })\">Transaction</a>. The promise has a method named &quot;cancel&quot; which cancels the ongoing API call.</li> </ul> "}]},{"id":"commit","name":"commit","type":"instance","description":"<p>Commits a transaction. The request includes the mutations to be applied to rows in the database.</p><p><code>Commit</code> might return an <code>ABORTED</code> error. This can occur at any time; commonly, the cause is conflicts with concurrent transactions. However, it can also happen for a variety of other reasons. If <code>Commit</code> returns <code>ABORTED</code>, the caller should re-attempt the transaction from the beginning, re-using the same session.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L862","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedSession = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nvar mutations = [];\nvar request = {\n    session: formattedSession,\n    mutations: mutations\n};\nclient.commit(request).then(function(responses) {\n    var response = responses[0];\n    // doThingsWith(response)\n}).catch(function(err) {\n    console.error(err);\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.session","description":"<p> Required. The session in which the transaction to be committed is running.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.mutations","description":"<p> The mutations to be executed when this transaction commits. All  mutations are applied atomically, in the order they appear in  this list.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Mutation'\n        })\">Mutation</a></p>","types":["Object[]"],"optional":false,"nullable":false},{"name":"request.transactionId","description":"<p> Commit a previously-started transaction.</p>","types":["string"],"optional":true,"nullable":false},{"name":"request.singleUseTransaction","description":"<p> Execute mutations in a temporary transaction. Note that unlike  commit of a previously-started transaction, commit with a  temporary transaction is non-idempotent. That is, if the  <code>CommitRequest</code> is sent to Cloud Spanner more than once (for  instance, due to retries in the application, or in the  transport library), it is possible that the mutations are  executed more than once. If this is undesirable, use  {@link BeginTransaction} and  {@link Commit} instead.</p><p> This object should have the same structure as <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TransactionOptions'\n        })\">TransactionOptions</a></p>","types":["Object"],"optional":true,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false},{"name":"callback","description":"<p> The function which will be called with the result of the API call.</p><p> The second parameter to the callback is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'CommitResponse'\n        })\">CommitResponse</a>.</p>","types":["function(Error|null, Object|null)"],"optional":true,"nullable":false}],"exceptions":[],"returns":[{"types":["Promise"],"description":"<ul> <li>The promise which resolves to an array. The first element of the array is an object representing <a ui-sref=\"docs.service({\n          serviceId: '{{ service.parent }}/{{service.path.split('/').shift()}}/data_types',\n          method: 'CommitResponse'\n        })\">CommitResponse</a>. The promise has a method named &quot;cancel&quot; which cancels the ongoing API call.</li> </ul> "}]},{"id":"rollback","name":"rollback","type":"instance","description":"<p>Rolls back a transaction, releasing any locks it holds. It is a good idea to call this for any transaction that includes one or more {@link Read} or {@link ExecuteSql} requests and ultimately decides not to commit.</p><p><code>Rollback</code> returns <code>OK</code> if it successfully aborts the transaction, the transaction was already aborted, or the transaction is not found. <code>Rollback</code> never returns <code>ABORTED</code>.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L911","resources":[],"examples":[{"code":"\nvar client = spannerV1.spannerClient();\nvar formattedSession = client.sessionPath(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\", \"[SESSION]\");\nvar transactionId = '';\nvar request = {\n    session: formattedSession,\n    transactionId: transactionId\n};\nclient.rollback(request).catch(function(err) {\n    console.error(err);\n});"}],"params":[{"name":"request","description":"<p> The request object that will be sent.</p>","types":["Object"],"optional":false,"nullable":false},{"name":"request.session","description":"<p> Required. The session in which the transaction to roll back is running.</p>","types":["string"],"optional":false,"nullable":false},{"name":"request.transactionId","description":"<p> Required. The transaction to roll back.</p>","types":["string"],"optional":false,"nullable":false},{"name":"options","description":"<p> Optional parameters. You can override the default settings for this call, e.g, timeout,  retries, paginations, etc. See <a href=\"https://googleapis.github.io/gax-nodejs/global.html#CallOptions\">gax.CallOptions</a> for the details.</p>","types":["Object"],"optional":true,"nullable":false},{"name":"callback","description":"<p> The function which will be called with the result of the API call.</p>","types":["function(Error|null)"],"optional":true,"nullable":false}],"exceptions":[],"returns":[{"types":["Promise"],"description":"<ul> <li>The promise which resolves when API call finishes. The promise has a method named &quot;cancel&quot; which cancels the ongoing API call.</li> </ul> "}]},{"id":"spannerClient","name":"spannerClient","type":"instance","description":"<p>Build a new instance of {@link SpannerClient}.</p>","source":"packages\\spanner\\src\\v1\\spanner_client.js#L949","resources":[],"examples":[],"params":[{"name":"opts","description":"<ul> <li>The optional parameters.</li> </ul> ","types":["Object"],"optional":true,"nullable":false},{"name":"opts.servicePath","description":"<p> The domain name of the API remote host.</p>","types":["String"],"optional":true,"nullable":false},{"name":"opts.port","description":"<p> The port on which to connect to the remote host.</p>","types":["number"],"optional":true,"nullable":false},{"name":"opts.sslCreds","description":"<p> A ClientCredentials for use with an SSL-enabled channel.</p>","types":["grpc.ClientCredentials"],"optional":true,"nullable":false},{"name":"opts.clientConfig","description":"<p> The customized config to build the call settings. See  {@link gax.constructSettings} for the format.</p>","types":["Object"],"optional":true,"nullable":false}],"exceptions":[],"returns":[]}],"path":"v1/spanner_client.json"}