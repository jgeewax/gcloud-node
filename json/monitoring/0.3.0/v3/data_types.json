{"name":"Data Types","methods":[{"id":"TypedValue","name":"TypedValue","type":"instance","description":"<p>A single strongly-typed value.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_common.js#L47","resources":[],"examples":[],"params":[{"name":"boolValue","description":"<p> A Boolean value: <code>true</code> or <code>false</code>.</p>","types":["boolean"],"optional":false,"nullable":false},{"name":"int64Value","description":"<p> A 64-bit integer. Its range is approximately &plusmn;9.2x10<sup>18</sup>.</p>","types":["number"],"optional":false,"nullable":false},{"name":"doubleValue","description":"<p> A 64-bit double-precision floating-point number. Its magnitude  is approximately &plusmn;10<sup>&plusmn;300</sup> and it has 16  significant digits of precision.</p>","types":["number"],"optional":false,"nullable":false},{"name":"stringValue","description":"<p> A variable-length string value.</p>","types":["string"],"optional":false,"nullable":false},{"name":"distributionValue","description":"<p> A distribution value.</p><p> This object should have the same structure as google.api.Distribution</p>","types":["Object"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"TimeInterval","name":"TimeInterval","type":"instance","description":"<p>A time interval extending just after a start time through an end time. If the start time is the same as the end time, then the interval represents a single point in time.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_common.js#L71","resources":[],"examples":[],"params":[{"name":"endTime","description":"<p> Required. The end of the time interval.</p><p> This object should have the same structure as google.protobuf.Timestamp</p>","types":["Object"],"optional":false,"nullable":false},{"name":"startTime","description":"<p> Optional. The beginning of the time interval. The default value  for the start time is the end time. The start time must not be  later than the end time.</p><p> This object should have the same structure as google.protobuf.Timestamp</p>","types":["Object"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"Aggregation","name":"Aggregation","type":"instance","description":"<p>Describes how to combine multiple time series to provide different views of the data. Aggregation consists of an alignment step on individual time series (<code>per_series_aligner</code>) followed by an optional reduction of the data across different time series (<code>cross_series_reducer</code>). For more details, see <a href=\"https://cloud.google.com/monitoring/api/learn_more#aggregation\">Aggregation</a>.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_common.js#L143","resources":[],"examples":[],"params":[{"name":"alignmentPeriod","description":"<p> The alignment period for per-{@link time series}  alignment. If present, <code>alignmentPeriod</code> must be at least 60  seconds. After per-time series alignment, each time series will  contain data points only on the period boundaries. If  <code>perSeriesAligner</code> is not specified or equals <code>ALIGN_NONE</code>, then  this field is ignored. If <code>perSeriesAligner</code> is specified and  does not equal <code>ALIGN_NONE</code>, then this field must be defined;  otherwise an error is returned.</p><p> This object should have the same structure as google.protobuf.Duration</p>","types":["Object"],"optional":false,"nullable":false},{"name":"perSeriesAligner","description":"<p> The approach to be used to align individual time series. Not all  alignment functions may be applied to all time series, depending  on the metric type and value type of the original time  series. Alignment may change the metric type or the value type of  the time series.</p><p> Time series data must be aligned in order to perform cross-time  series reduction. If <code>crossSeriesReducer</code> is specified, then  <code>perSeriesAligner</code> must be specified and not equal <code>ALIGN_NONE</code>  and <code>alignmentPeriod</code> must be specified; otherwise, an error is  returned.</p><p> The number should be among the values of <a ng-if=\"service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.parent}}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Aligner'\n        })\">Aligner</a>\n\n        <a ng-if=\"!service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.title.split('V')[0] + '/v' + service.title.split('V')[1]}}/data_types',\n          method: 'Aligner'\n        })\">Aligner</a></p>","types":["number"],"optional":false,"nullable":false},{"name":"crossSeriesReducer","description":"<p> The approach to be used to combine time series. Not all reducer  functions may be applied to all time series, depending on the  metric type and the value type of the original time  series. Reduction may change the metric type of value type of the  time series.</p><p> Time series data must be aligned in order to perform cross-time  series reduction. If <code>crossSeriesReducer</code> is specified, then  <code>perSeriesAligner</code> must be specified and not equal <code>ALIGN_NONE</code>  and <code>alignmentPeriod</code> must be specified; otherwise, an error is  returned.</p><p> The number should be among the values of <a ng-if=\"service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.parent}}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Reducer'\n        })\">Reducer</a>\n\n        <a ng-if=\"!service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.title.split('V')[0] + '/v' + service.title.split('V')[1]}}/data_types',\n          method: 'Reducer'\n        })\">Reducer</a></p>","types":["number"],"optional":false,"nullable":false},{"name":"groupByFields","description":"<p> The set of fields to preserve when <code>crossSeriesReducer</code> is  specified. The <code>groupByFields</code> determine how the time series are  partitioned into subsets prior to applying the aggregation  function. Each subset contains time series that have the same  value for each of the grouping fields. Each individual time  series is a member of exactly one subset. The  <code>crossSeriesReducer</code> is applied to each subset of time series.  It is not possible to reduce across different resource types, so  this field implicitly contains <code>resource.type</code>. Fields not  specified in <code>groupByFields</code> are aggregated away. If  <code>groupByFields</code> is not specified and all the time series have  the same resource type, then the time series are aggregated into  a single output time series. If <code>crossSeriesReducer</code> is not  defined, this field is ignored.</p>","types":["string[]"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"Aligner","name":"Aligner","type":"instance","description":"<p>The Aligner describes how to bring the data points in a single time series into temporal alignment.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_common.js#L152","resources":[],"examples":[],"params":[],"exceptions":[],"returns":[]},{"id":"Reducer","name":"Reducer","type":"instance","description":"<p>A Reducer describes how to aggregate data points from multiple time series into a single time series.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_common.js#L309","resources":[],"examples":[],"params":[],"exceptions":[],"returns":[]},{"type":"instance","description":"<p>Distribution contains summary statistics for a population of values and, optionally, a histogram representing the distribution of those values across a specified set of histogram buckets.</p><p>The summary statistics are the count, mean, sum of the squared deviation from the mean, the minimum, and the maximum of the set of population of values.</p><p>The histogram is based on a sequence of buckets and gives a count of values that fall into each bucket. The boundaries of the buckets are given either explicitly or by specifying parameters for a method of computing them (buckets of fixed width or buckets of exponentially increasing width).</p><p>Although it is not forbidden, it is generally a bad idea to include non-finite values (infinities or NaNs) in the population of values, as this will render the <code>mean</code> and <code>sum_of_squared_deviation</code> fields meaningless.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_google_api_distribution.js#L85","resources":[],"examples":[],"params":[{"name":"count","description":"<p> The number of values in the population. Must be non-negative.</p>","types":["number"],"optional":false,"nullable":false},{"name":"mean","description":"<p> The arithmetic mean of the values in the population. If <code>count</code> is zero  then this field must be zero.</p>","types":["number"],"optional":false,"nullable":false},{"name":"sumOfSquaredDeviation","description":"<p> The sum of squared deviations from the mean of the values in the  population. For values x_i this is:</p><pre><code> Sum[i=1..n](https://cloud.google.com(x_i - mean)^2) </code></pre><p> Knuth, &quot;The Art of Computer Programming&quot;, Vol. 2, page 323, 3rd edition  describes Welford&#39;s method for accumulating this sum in one pass.</p><p> If <code>count</code> is zero then this field must be zero.</p>","types":["number"],"optional":false,"nullable":false},{"name":"range","description":"<p> If specified, contains the range of the population values. The field  must not be present if the <code>count</code> is zero.</p><p> This object should have the same structure as google.api.Distribution.Range</p>","types":["Object"],"optional":false,"nullable":false},{"name":"bucketOptions","description":"<p> Defines the histogram bucket boundaries.</p><p> This object should have the same structure as google.api.Distribution.BucketOptions</p>","types":["Object"],"optional":false,"nullable":false},{"name":"bucketCounts","description":"<p> If <code>bucket_options</code> is given, then the sum of the values in <code>bucket_counts</code>  must equal the value in <code>count</code>. If <code>bucket_options</code> is not given, no  <code>bucket_counts</code> fields may be given.</p><p> Bucket counts are given in order under the numbering scheme described  above (the underflow bucket has number 0; the finite buckets, if any,  have numbers 1 through N-2; the overflow bucket has number N-1).</p><p> The size of <code>bucket_counts</code> must be no greater than N as defined in  <code>bucket_options</code>.</p><p> Any suffix of trailing zero bucket_count fields may be omitted.</p>","types":["number[]"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"type":"instance","description":"<p>A description of a label.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_google_api_label.js#L39","resources":[],"examples":[],"params":[{"name":"key","description":"<p> The label key.</p>","types":["string"],"optional":false,"nullable":false},{"name":"valueType","description":"<p> The type of data that can be assigned to the label.</p><p> The number should be among the values of google.api.LabelDescriptor.ValueType</p>","types":["number"],"optional":false,"nullable":false},{"name":"description","description":"<p> A human-readable description for the label.</p>","types":["string"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"type":"instance","description":"<p>Defines a metric type and its schema. Once a metric descriptor is created, deleting or altering it stops data collection and makes the metric type&#39;s existing data unusable.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_google_api_metric.js#L144","resources":[],"examples":[],"params":[{"name":"name","description":"<p> The resource name of the metric descriptor. Depending on the  implementation, the name typically includes: (1) the parent resource name  that defines the scope of the metric type or of its data; and (2) the  metric&#39;s URL-encoded type, which also appears in the <code>type</code> field of this  descriptor. For example, following is the resource name of a custom  metric within the GCP project <code>my-project-id</code>:</p><pre><code> &quot;projects/my-project-id/metricDescriptors/custom.googleapis.com%2Finvoice%2Fpaid%2Famount&quot; </code></pre>","types":["string"],"optional":false,"nullable":false},{"name":"type","description":"<p> The metric type, including its DNS name prefix. The type is not  URL-encoded. All user-defined custom metric types have the DNS name  <code>custom.googleapis.com</code>. Metric types should use a natural hierarchical  grouping. For example:</p><pre><code> &quot;custom.googleapis.com/invoice/paid/amount&quot; &quot;appengine.googleapis.com/http/server/response_latencies&quot; </code></pre>","types":["string"],"optional":false,"nullable":false},{"name":"labels","description":"<p> The set of labels that can be used to describe a specific  instance of this metric type. For example, the  <code>appengine.googleapis.com/http/server/response_latencies</code> metric  type has a label for the HTTP response code, <code>response_code</code>, so  you can look at latencies for successful responses or just  for responses that failed.</p><p> This object should have the same structure as google.api.LabelDescriptor</p>","types":["Object[]"],"optional":false,"nullable":false},{"name":"metricKind","description":"<p> Whether the metric records instantaneous values, changes to a value, etc.  Some combinations of <code>metric_kind</code> and <code>value_type</code> might not be supported.</p><p> The number should be among the values of google.api.MetricDescriptor.MetricKind</p>","types":["number"],"optional":false,"nullable":false},{"name":"valueType","description":"<p> Whether the measurement is an integer, a floating-point number, etc.  Some combinations of <code>metric_kind</code> and <code>value_type</code> might not be supported.</p><p> The number should be among the values of google.api.MetricDescriptor.ValueType</p>","types":["number"],"optional":false,"nullable":false},{"name":"unit","description":"<p> The unit in which the metric value is reported. It is only applicable  if the <code>value_type</code> is <code>INT64</code>, <code>DOUBLE</code>, or <code>DISTRIBUTION</code>. The  supported units are a subset of <a href=\"http://unitsofmeasure.org/ucum.html\">The Unified Code for Units of  Measure</a> standard:</p><p> <strong>Basic units (UNIT)</strong></p><ul> <li><code>bit</code> bit</li> <li><code>By</code> byte</li> <li><code>s</code> second</li> <li><code>min</code> minute</li> <li><code>h</code> hour</li> <li><p><code>d</code> day</p><p><strong>Prefixes (PREFIX)</strong></p></li> <li><p><code>k</code> kilo (10**3)</p></li> <li><code>M</code> mega (10**6)</li> <li><code>G</code> giga (10**9)</li> <li><code>T</code> tera (10**12)</li> <li><code>P</code> peta (10**15)</li> <li><code>E</code> exa (10**18)</li> <li><code>Z</code> zetta (10**21)</li> <li><code>Y</code> yotta (10**24)</li> <li><code>m</code> milli (10**-3)</li> <li><code>u</code> micro (10**-6)</li> <li><code>n</code> nano (10**-9)</li> <li><code>p</code> pico (10**-12)</li> <li><code>f</code> femto (10**-15)</li> <li><code>a</code> atto (10**-18)</li> <li><code>z</code> zepto (10**-21)</li> <li><code>y</code> yocto (10**-24)</li> <li><code>Ki</code> kibi (2**10)</li> <li><code>Mi</code> mebi (2**20)</li> <li><code>Gi</code> gibi (2**30)</li> <li><p><code>Ti</code> tebi (2**40)</p><p><strong>Grammar</strong></p><p>The grammar includes the dimensionless unit <code>1</code>, such as <code>1/s</code>.</p><p>The grammar also includes these connectors:</p></li> <li><p><code>/</code> division (as an infix operator, e.g. <code>1/s</code>).</p></li> <li><p><code>.</code> multiplication (as an infix operator, e.g. <code>GBy.d</code>)</p><p>The grammar for a unit is as follows:</p><p> Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ;</p><p> Component = [ PREFIX ] UNIT [ Annotation ]</p><pre><code> | Annotation | &quot;1&quot; ; </code></pre><p> Annotation = &quot;{&quot; NAME &quot;}&quot; ;</p><p>Notes:</p></li> <li><p><code>Annotation</code> is just a comment if it follows a <code>UNIT</code> and is  equivalent to <code>1</code> if it is used alone. For examples,  <code>{requests}/s == 1/s</code>, <code>By{transmitted}/s == By/s</code>.</p></li> <li><code>NAME</code> is a sequence of non-blank printable ASCII characters not  containing &#39;{&#39; or &#39;}&#39;.</li> </ul> ","types":["string"],"optional":false,"nullable":false},{"name":"description","description":"<p> A detailed description of the metric, which can be used in documentation.</p>","types":["string"],"optional":false,"nullable":false},{"name":"displayName","description":"<p> A concise name for the metric, which can be displayed in user interfaces.  Use sentence case without an ending period, for example &quot;Request count&quot;.</p>","types":["string"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"type":"instance","description":"<p>An object that describes the schema of a {@link MonitoredResource} object using a type name and a set of labels. For example, the monitored resource descriptor for Google Compute Engine VM instances has a type of <code>&quot;gce_instance&quot;</code> and specifies the use of the labels <code>&quot;instance_id&quot;</code> and <code>&quot;zone&quot;</code> to identify particular VM instances.</p><p>Different APIs can support different monitored resource types. APIs generally provide a <code>list</code> method that returns the monitored resource descriptors used by the API.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_google_api_monitored_resource.js#L66","resources":[],"examples":[],"params":[{"name":"name","description":"<p> Optional. The resource name of the monitored resource descriptor:  <code>&quot;projects/{project_id}/monitoredResourceDescriptors/{type}&quot;</code> where  {type} is the value of the <code>type</code> field in this object and  {project_id} is a project ID that provides API-specific context for  accessing the type. APIs that do not use project information can use the  resource name format <code>&quot;monitoredResourceDescriptors/{type}&quot;</code>.</p>","types":["string"],"optional":false,"nullable":false},{"name":"type","description":"<p> Required. The monitored resource type. For example, the type  <code>&quot;cloudsql_database&quot;</code> represents databases in Google Cloud SQL.  The maximum length of this value is 256 characters.</p>","types":["string"],"optional":false,"nullable":false},{"name":"displayName","description":"<p> Optional. A concise name for the monitored resource type that might be  displayed in user interfaces. It should be a Title Cased Noun Phrase,  without any article or other determiners. For example,  <code>&quot;Google Cloud SQL Database&quot;</code>.</p>","types":["string"],"optional":false,"nullable":false},{"name":"description","description":"<p> Optional. A detailed description of the monitored resource type that might  be used in documentation.</p>","types":["string"],"optional":false,"nullable":false},{"name":"labels","description":"<p> Required. A set of labels used to describe instances of this monitored  resource type. For example, an individual Google Cloud SQL database is  identified by values for the labels <code>&quot;database_id&quot;</code> and <code>&quot;zone&quot;</code>.</p><p> This object should have the same structure as google.api.LabelDescriptor</p>","types":["Object[]"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"type":"instance","description":"<p>A Duration represents a signed, fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like &quot;day&quot; or &quot;month&quot;. It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately +-10,000 years.</p><p>Example 1: Compute Duration from two Timestamps in pseudo code.</p><pre><code>Timestamp start = ...; Timestamp end = ...; Duration duration = ...; duration.seconds = end.seconds - start.seconds; duration.nanos = end.nanos - start.nanos; if (duration.seconds &lt; 0 &amp;&amp; duration.nanos &gt; 0) { duration.seconds += 1; duration.nanos -= 1000000000; } else if (durations.seconds &gt; 0 &amp;&amp; duration.nanos &lt; 0) { duration.seconds -= 1; duration.nanos += 1000000000; } </code></pre><p>Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.</p><pre><code>Timestamp start = ...; Duration duration = ...; Timestamp end = ...; end.seconds = start.seconds + duration.seconds; end.nanos = start.nanos + duration.nanos; if (end.nanos &lt; 0) { end.seconds -= 1; end.nanos += 1000000000; } else if (end.nanos &gt;= 1000000000) { end.seconds += 1; end.nanos -= 1000000000; } </code></pre><p>Example 3: Compute Duration from datetime.timedelta in Python.</p><pre><code>td = datetime.timedelta(days=3, minutes=10) duration = Duration() duration.FromTimedelta(td) </code></pre>","source":"packages\\monitoring\\src\\v3\\doc\\doc_google_protobuf_duration.js#L85","resources":[],"examples":[],"params":[{"name":"seconds","description":"<p> Signed seconds of the span of time. Must be from -315,576,000,000  to +315,576,000,000 inclusive.</p>","types":["number"],"optional":false,"nullable":false},{"name":"nanos","description":"<p> Signed fractions of a second at nanosecond resolution of the span  of time. Durations less than one second are represented with a 0  <code>seconds</code> field and a positive or negative <code>nanos</code> field. For durations  of one second or more, a non-zero value for the <code>nanos</code> field must be  of the same sign as the <code>seconds</code> field. Must be from -999,999,999  to +999,999,999 inclusive.</p>","types":["number"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"type":"instance","description":"<p>A Timestamp represents a point in time independent of any time zone or calendar, represented as seconds and fractions of seconds at nanosecond resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian Calendar which extends the Gregorian calendar backwards to year one. It is encoded assuming all minutes are 60 seconds long, i.e. leap seconds are &quot;smeared&quot; so that no leap second table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By restricting to that range, we ensure that we can convert to and from RFC 3339 date strings. See <a href=\"https://www.ietf.org/rfc/rfc3339.txt\">https://www.ietf.org/rfc/rfc3339.txt</a>.</p><p>Example 1: Compute Timestamp from POSIX <code>time()</code>.</p><pre><code>Timestamp timestamp; timestamp.set_seconds(time(NULL)); timestamp.set_nanos(0); </code></pre><p>Example 2: Compute Timestamp from POSIX <code>gettimeofday()</code>.</p><pre><code>struct timeval tv; gettimeofday(&amp;tv, NULL); Timestamp timestamp; timestamp.set_seconds(tv.tv_sec); timestamp.set_nanos(tv.tv_usec * 1000); </code></pre><p>Example 3: Compute Timestamp from Win32 <code>GetSystemTimeAsFileTime()</code>.</p><pre><code>FILETIME ft; GetSystemTimeAsFileTime(&amp;ft); UINT64 ticks = (((UINT64)ft.dwHighDateTime) &lt;&lt; 32) | ft.dwLowDateTime; // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z. Timestamp timestamp; timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL)); timestamp.set_nanos((INT32) ((ticks % 10000000) * 100)); </code></pre><p>Example 4: Compute Timestamp from Java <code>System.currentTimeMillis()</code>.</p><pre><code>long millis = System.currentTimeMillis(); Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000) .setNanos((int) ((millis % 1000) * 1000000)).build(); </code></pre><p>Example 5: Compute Timestamp from current time in Python.</p><pre><code>timestamp = Timestamp() timestamp.GetCurrentTime() </code></pre>","source":"packages\\monitoring\\src\\v3\\doc\\doc_google_protobuf_timestamp.js#L89","resources":[],"examples":[],"params":[{"name":"seconds","description":"<p> Represents seconds of UTC time since Unix epoch  1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to  9999-12-31T23:59:59Z inclusive.</p>","types":["number"],"optional":false,"nullable":false},{"name":"nanos","description":"<p> Non-negative fractions of a second at nanosecond resolution. Negative  second values with fractions must still have non-negative nanos values  that count forward in time. Must be from 0 to 999,999,999  inclusive.</p>","types":["number"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"Group","name":"Group","type":"instance","description":"<p>The description of a dynamic collection of monitored resources. Each group has a filter that is matched against monitored resources and their associated metadata. If a group&#39;s filter matches an available monitored resource, then that resource is a member of that group. Groups can contain any number of monitored resources, and each monitored resource can be a member of any number of groups.</p><p>Groups can be nested in parent-child hierarchies. The <code>parentName</code> field identifies an optional parent for each group. If a group has a parent, then the only monitored resources available to be matched by the group&#39;s filter are the resources contained in the parent group. In other words, a group contains the monitored resources that match its filter and the filters of all the group&#39;s ancestors. A group without a parent can contain any monitored resource.</p><p>For example, consider an infrastructure running a set of instances with two user-defined tags: <code>&quot;environment&quot;</code> and <code>&quot;role&quot;</code>. A parent group has a filter, <code>environment=&quot;production&quot;</code>. A child of that parent group has a filter, <code>role=&quot;transcoder&quot;</code>. The parent group contains all instances in the production environment, regardless of their roles. The child group contains instances that have the transcoder role <em>and</em> are in the production environment.</p><p>The monitored resources contained in a group can change at any moment, depending on what resources exist and what filters are associated with the group and its ancestors.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_group.js#L75","resources":[],"examples":[],"params":[{"name":"name","description":"<p> Output only. The name of this group. The format is  <code>&quot;projects/{project_id_or_number}/groups/{group_id}&quot;</code>.  When creating a group, this field is ignored and a new name is created  consisting of the project specified in the call to <code>CreateGroup</code>  and a unique <code>{group_id}</code> that is generated automatically.</p>","types":["string"],"optional":false,"nullable":false},{"name":"displayName","description":"<p> A user-assigned name for this group, used only for display purposes.</p>","types":["string"],"optional":false,"nullable":false},{"name":"parentName","description":"<p> The name of the group&#39;s parent, if it has one.  The format is <code>&quot;projects/{project_id_or_number}/groups/{group_id}&quot;</code>.  For groups with no parent, <code>parentName</code> is the empty string, <code>&quot;&quot;</code>.</p>","types":["string"],"optional":false,"nullable":false},{"name":"filter","description":"<p> The filter used to determine which monitored resources belong to this group.</p>","types":["string"],"optional":false,"nullable":false},{"name":"isCluster","description":"<p> If true, the members of this group are considered to be a cluster.  The system can perform additional analysis on groups that are clusters.</p>","types":["boolean"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"Point","name":"Point","type":"instance","description":"<p>A single data point in a time series.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_metric.js#L45","resources":[],"examples":[],"params":[{"name":"interval","description":"<p> The time interval to which the data point applies. For GAUGE metrics, only  the end time of the interval is used. For DELTA metrics, the start and end  time should specify a non-zero interval, with subsequent points specifying  contiguous and non-overlapping intervals. For CUMULATIVE metrics, the  start and end time should specify a non-zero interval, with subsequent  points specifying the same start time and increasing end times, until an  event resets the cumulative value to zero and sets a new start time for the  following points.</p><p> This object should have the same structure as <a ng-if=\"service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.parent}}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TimeInterval'\n        })\">TimeInterval</a>\n\n        <a ng-if=\"!service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.title.split('V')[0] + '/v' + service.title.split('V')[1]}}/data_types',\n          method: 'TimeInterval'\n        })\">TimeInterval</a></p>","types":["Object"],"optional":false,"nullable":false},{"name":"value","description":"<p> The value of the data point.</p><p> This object should have the same structure as <a ng-if=\"service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.parent}}/{{service.path.split('/').shift()}}/data_types',\n          method: 'TypedValue'\n        })\">TypedValue</a>\n\n        <a ng-if=\"!service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.title.split('V')[0] + '/v' + service.title.split('V')[1]}}/data_types',\n          method: 'TypedValue'\n        })\">TypedValue</a></p>","types":["Object"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]},{"id":"TimeSeries","name":"TimeSeries","type":"instance","description":"<p>A collection of data points that describes the time-varying values of a metric. A time series is identified by a combination of a fully-specified monitored resource and a fully-specified metric. This type is used for both listing and creating time series.</p>","source":"packages\\monitoring\\src\\v3\\doc\\doc_metric.js#L105","resources":[],"examples":[],"params":[{"name":"metric","description":"<p> The associated metric. A fully-specified metric used to identify the time  series.</p><p> This object should have the same structure as google.api.Metric</p>","types":["Object"],"optional":false,"nullable":false},{"name":"resource","description":"<p> The associated resource. A fully-specified monitored resource used to  identify the time series.</p><p> This object should have the same structure as google.api.MonitoredResource</p>","types":["Object"],"optional":false,"nullable":false},{"name":"metricKind","description":"<p> The metric kind of the time series. When listing time series, this metric  kind might be different from the metric kind of the associated metric if  this time series is an alignment or reduction of other time series.</p><p> When creating a time series, this field is optional. If present, it must be  the same as the metric kind of the associated metric. If the associated  metric&#39;s descriptor must be auto-created, then this field specifies the  metric kind of the new descriptor and must be either <code>GAUGE</code> (the default)  or <code>CUMULATIVE</code>.</p><p> The number should be among the values of google.api.MetricDescriptor.MetricKind</p>","types":["number"],"optional":false,"nullable":false},{"name":"valueType","description":"<p> The value type of the time series. When listing time series, this value  type might be different from the value type of the associated metric if  this time series is an alignment or reduction of other time series.</p><p> When creating a time series, this field is optional. If present, it must be  the same as the type of the data in the <code>points</code> field.</p><p> The number should be among the values of google.api.MetricDescriptor.ValueType</p>","types":["number"],"optional":false,"nullable":false},{"name":"points","description":"<p> The data points of this time series. When listing time series, the order of  the points is specified by the list method.</p><p> When creating a time series, this field must contain exactly one point and  the point&#39;s type must be the same as the value type of the associated  metric. If the associated metric&#39;s descriptor must be auto-created, then  the value type of the descriptor is determined by the point&#39;s type, which  must be <code>BOOL</code>, <code>INT64</code>, <code>DOUBLE</code>, or <code>DISTRIBUTION</code>.</p><p> This object should have the same structure as <a ng-if=\"service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.parent}}/{{service.path.split('/').shift()}}/data_types',\n          method: 'Point'\n        })\">Point</a>\n\n        <a ng-if=\"!service.parent\" ui-sref=\"docs.service({\n          serviceId: '{{service.title.split('V')[0] + '/v' + service.title.split('V')[1]}}/data_types',\n          method: 'Point'\n        })\">Point</a></p>","types":["Object[]"],"optional":false,"nullable":false}],"exceptions":[],"returns":[]}],"path":"v3/data_types.json","description":"\n          <table class=\"table\">\n            <thead>\n              <tr>\n                <th>Class</th>\n                <th>Description</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr ng-repeat=\"method in service.methods\" ng-if=\"method.name\">\n                <td>\n                  <a ui-sref=\"docs.service({ method: method.id })\" class=\"skip-external-link\">\n                    {{method.name}}\n                  </a>\n                </td>\n                <td>\n                  <span ng-bind-html=\"method.description\">\n                    {{method.description}}\n                  </span>\n                  <span ng-if=\"!method.description && method.name.includes('Request')\">\n                    The request for {{method.name}}.\n                  </span>\n                  <span ng-if=\"!method.description && method.name.includes('Response')\">\n                    The response for {{method.name}}.\n                  </span>\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        ","id":"monitoring/v3/data_types"}